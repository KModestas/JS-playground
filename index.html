<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vanilla JS</title>
</head>

<body>

</body>

<!-- When this script is executed by the browser, it will get its own Global Execution content (GEC), then each function call will get its own Function Execution context (FEC). GEC will always be at the bottom of the callstack (LIFO). -->
<script>
  function varAndLetScope() {
    if (true) {
      var x = 5; // x is defined within the entire function because var is function-scoped
      let y = 6; // y is only defined within this if block because let is block-scoped
    }

    console.log('var: ', x); // This will output '5'.
    console.log('let: ', y); // This will throw a ReferenceError: y is not defined.
  }

  varAndLetScope();
</script>

<script>
  //
  console.log(1);

  // macrotaks 
  setTimeout(() => console.log(2));

  // microtask
  Promise.resolve().then(() => console.log(3));

  // microtask => macrotask
  Promise.resolve().then(() => setTimeout(() => console.log(4)));

  // microtask
  Promise.resolve().then(() => console.log(5));

  // macrotask
  setTimeout(() => console.log(6));

  //
  console.log(7);
</script>

<script>
  // A single promise can have multiple then handlers attached to it
  let p = Promise.resolve('p value');

  // each of these handlers will be added to the microtask queue without waiting for one another and will recieve the same value from resolve(). They do NOT depend on each other.
  p.then(value => {
    console.log('first handler:', value); // => "first handler: p value
  });

  p.then(value => {
    console.log('second handler:', value); // => "second handler: p value"
  });


  // ..or a single promise can have a single then handler
  let p2 = Promise.resolve('p2 value');

  // p2 has a single then handler. The handler returns a NEW promise which has its own then handler. The next handler in the chain will only be be executed and added to the microtask queue once the previous one has resolved. Each subsequent handler returns a NEW promise and is given a value from the previous handlers resolve function. Unlike the first example, they all depend on each other.
  p2.then(value => {
    console.log('first handler:', value); // => "first handler: p2 value

    // Even if you dont explicitly return a Promise, the return value of your callback will be wrapped in a new Promise which will resolve or reject if an error is thrown.
    return 'Value from first handler';
  }).then(value => {
    console.log('second handler:', value); // => "second handler: value from first handler"
  });

  // catch handlers also return a promise allowing them to be chained:
  Promise.reject("Error")
    .then(result => {
      console.log("This won't be called");
      return result;
    })
    .catch(error => {
      console.log("Caught:", error); // Logs: "Caught: Error"
      return "Recovered";  // Resolve the promise with "Recovered"
    })
    // this handler belongs to the new promise returned by catch:
    .then(result => {
      console.log("After recovery:", result); // Logs: "After recovery: Recovered"
    })
    .catch(error => {
      console.log("This won't be called either");
    });

  // since fetch supports promises, you can imagine it internally returns a Promise constuctor that triggers some raw HTTP API and passes it a callback that calls resolve() or reject() depending on the result of the HTTP request.
  // If it didn't support promises, we would directly pass it a callback to be executed instead, like the old days.
  let promise = fetch('https://jsonplaceholder.typicode.com/posts/1');

  promise.then(res => {
    if (!res.ok) {
      throw new Error(`HTTP error! status: ${res.status}`);
    }
    // returns a new promise:
    return res.json();
  }).then(data => {
    let promise2 = new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve("Promise2 resolved!");
      }, 1000);
    });

    // When a then handler explicitly returns another promise, the promise returned by then will be synced up to this promise and will resolve with its value. If this promise has its own chain of promises, it will resolve with the value of the last promise in the chain. No matter how nested it gets, it always returns a new promise that resolves with the last value in the chain.
    return promise2
      .then(data => {
        console.log(value2); // logs "Promise2 resolved!"
        return "Value from Promise2's .then()";
      });
  })
    .then(data => {
      console.log(data); // logs "Value from Promise2's .then()"

      // NOTE: most promise will schedule macrotasks such as an API call or setTimeout
      setTimeout(() => {
        console.log("Timeout completed!");
      }, 2000);
    })
    .then(data => {
      console.log(data); // logs undefined
    })
    .catch(error => {
      console.log(`Fetch Error: ${error}`);
    });

  // for all intents and purposes you can think of this behavior as being exactly the same with an async function that has multiple await statements, the await statements can be seen as then handlers that return promises. The main async function is like the promise executor function.
  async function asyncFunction() {
    console.log("Start");
    await new Promise(resolve => setTimeout(resolve, 1000));
    await new Promise(resolve => setTimeout(resolve, 1000));
    console.log("End");
  }
  // when an async function encounters an await, it runs that code as normal (promise executor function is invoked and its callback is added to microtask queue) and returns the value of the promise. At the same time, it also creates a seperate continuation function with all code after the first await. This continuation function is added to the microtask queue after that await promise is settled. Essentially the async function is split into multiple functions to be executed (and asyncFunction itself gets popped off the execution stack)
  // remember each continuation function will return its promise
  // https://chat.openai.com/c/b5e48b84-d2b5-4cde-b88a-329eb9f4170f

  asyncFunction();

  // Its important to note that everything in this script will be executed synchronously! This asyncFunction does not need to wait for any of the promises above to resolve before being invoked. The microtask queue will contain microtasks from both of these promises at the same time. When a promise is being waited, it will move on to the microtask of the next promise and so on and so forth. At any given time, there will be 2 microtasks in the queue, one for each promise. (only 1 microtask exists in the queue per promise)
</script>

<!-- by value or by reference: -->
<script>
  let a = { foo: "bar" }
  let b = a
  // b => { foo: "bar" }

  b.baz = "qux"
  // a, b => { foo: "bar", baz: "qux" }

  a = {}
  // a => {}
  // b => { foo: "bar", baz: "qux" }
  // assigning a new object breaks the reference change
</script>

</html>