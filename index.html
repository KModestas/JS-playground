<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vanilla JS</title>
</head>

<body>

</body>

<!-- When this script is executed by the browser, it will get its own Global Execution content (GEC), then each function call will get its own Function Execution context (FEC). GEC will always be at the bottom of the callstack (LIFO). -->
<script>
  function varAndLetScope() {
    if (true) {
      var x = 5; // x is defined within the entire function because var is function-scoped
      let y = 6; // y is only defined within this if block because let is block-scoped
    }

    console.log('var: ', x); // This will output '5'.
    console.log('let: ', y); // This will throw a ReferenceError: y is not defined.
  }

  varAndLetScope();
</script>

<script>
  console.log(1);

  setTimeout(() => console.log(2));

  Promise.resolve().then(() => console.log(3));

  Promise.resolve().then(() => setTimeout(() => console.log(4)));

  Promise.resolve().then(() => console.log(5));

  setTimeout(() => console.log(6));

  console.log(7);
</script>

<script>
  // since fetch supports promises, you can imagine it returns a Promise constuctor that triggers some raw HTTP API and passes it a callback that calls resolve() or reject() depending on the result of the HTTP request.
  // If it didn't support promises, we would pass it a callback to be executed instead, like the old days.
  let promise = fetch('https://jsonplaceholder.typicode.com/posts/1');

  // when the promise is resolved, its handlers are triggered and their callbacks are added to the microtask queue. NOTE: only one microtask for each handler exists at any given time in the microtask queue (per Promise), once the microtask for a then handler is finished, the next one is added to the microtask queue and so on, they are not all added at once. 
  promise.then(res => {
    if (!res.ok) {
      throw new Error(`HTTP error! status: ${res.status}`);
    }
    return res.json();  // this returns a Promise
  }).then(data => {
    let promise2 = new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve("Promise2 resolved!");
      }, 1000);
    });

    // since this then() handler also returns a promise, the next then() handler will be called only when that promise is resolved. This behavior is mangaed by the javascript engine itself as part of the Promise/A+ specification). It is able to observe these "inner promises" and only add the next handler to the microtask queue when the inner promise is resolved.
    // also NOTE that this then handler does not remain on the microtask queue while waiting, it simply executes this code and is removed. When the promise resolves, the next then() handler is added to the microtask queue.
    // essentially, you can think of this chain of handlers are being flat, they will all run in order, wether they are outer or inner.
    return promise2
      .then(data => {
        console.log(value2); // logs "Promise2 resolved!"
        return "Value from Promise2's .then()";
      });
  })
    .then(data => {
      console.log(data); // logs "Value from Promise2's .then()"

      // since this then() handler does not return a promise (or anything for that matter), the next then() handler will be called immediately
      setTimeout(() => {
        console.log("Timeout completed!");
      }, 2000);
    })
    .then(data => {
      console.log(data); // logs undefined
    })
    .catch(error => {
      console.log(`Fetch Error: ${error}`);
    });

  // for all intents and purposes you can think of this behavior as being exactly the same with an async function that has multiple await statements, the await statements can be seen as then handlers that return promises. The async function is like the promise executor function.
  async function asyncFunction() {
    console.log("Start");
    await new Promise(resolve => setTimeout(resolve, 1000));
    await new Promise(resolve => setTimeout(resolve, 1000));
    console.log("End");
  }
  // when an async function encounters an await, it creates a seperate continuation function with all code after the await. This continuation function is added to the microtask queue after the await promise is resolved. Esserntially the async function is split into multiple functions (otherwise callstack will never be empty if that async function remained on the callstack and it would block the thread)
  // https://chat.openai.com/c/b5e48b84-d2b5-4cde-b88a-329eb9f4170f

  asyncFunction();

  // Its important to note that everything in this script will be executed synchronously! This asyncFunction does not need to wait for any of the promises above to resolve before being invoked. The microtask queue will contain microtasks from both of these promises at the same time. When a promise is being waited, it will move on the microtask of the next promise and so on and so forth. At any given time, there will be 2 microtasks in the queue, one for each promise. (only 1 microtask exists in the queue per promise)
</script>

<!-- by value or by reference: -->
<script>
  let a = { foo: "bar" }
  let b = a
  // b => { foo: "bar" }

  b.baz = "qux"
  // a, b => { foo: "bar", baz: "qux" }

  a = {}
  // a => {}
  // b => { foo: "bar", baz: "qux" }
  // assigning a new object breaks the reference change
</script>

</html>